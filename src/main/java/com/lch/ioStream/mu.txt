# 1. 基本概念
程序：完成特定的任务、用某种语言编写的一组指令的集合。一段静态的代码。
进程：正在运行的一个程序。
线程：进程细化为线程，是程序内部的一条执行路径。

# 2. 多线程的优点
1. 提高程序的响应。
2. 提高计算机系统CPU的利用率。
3. 改善程序结构。

# 3. 多线程的使用

## 3.1 多线程创建方式1： 继承Thread类

1. 创建一个继承于Tread类的子类
2. 重写Thread类的run( )
3. 创建Thread类的子类的对象
4. 通过此对象调用start( )
	1. 启动当前线程
	2. 调用当前线程的 run( ) 方法
	3. 只能启动一次 strat( )

```java
class MyThread extends Thread{
    @Override
    public void run() {
        System.out.println("这是MyThread");
    }
}
public class ThreadTest {

    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();
    }
}
```

或创建Thread类的匿名子类的方式：
```java
new Thread(() -> {
    for (int i = 1; i <= 100; i += 2) {
        System.out.println(Thread.currentThread().getName() + ":" + i);
    }
}).start();
```

## 3.2 多线程创建方式2： 实现Runnable接口的类
1. 创建一个实现了Runna接口的类
2. 实现类去实现Runable中的抽象方法：run( )
3. 创建实现类的对象
4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
5. 通过Thread类的对象调用start( )

```java
class AThread implements Runnable{

    @Override
    public void run() {
        System.out.println("这是实现Runnable的线程");
    }
}
public class ThreadTest3 {
    public static void main(String[] args) {
        AThread aThread = new AThread();
        //当前线程的run() -> 调用了Runnable类型的target的run()方法
        new Thread(aThread).start();
    }
}
```

优先选择实现Runnable接口的方式：
1. 没有单继承性的局限性
2. 更适合处理多个线程共享数据的情况

## 3.4 多线程创建方式3（JDK5）： 实现Callable接口
1. 创建一个实现Callable的实现类
2. 实现call方法，将此线程需要执行的操作声明再call( ) 中
3. 创建callable接口实现类的对象
4. 将此callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask的对象
5. 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Tread对象，并调用start( ) 方法。
6. 或去Callable中call方法的返回值

```java
class NumThread implements Callable{

    //2. 实现call方法，将此线程需要执行的操作声明再call( ) 中
    @Override
    public Object call() throws Exception {
        int sum = 0;
        for (int i = 0; i < 100; i++) {
            sum += i;
            System.out.println(sum);
        }
        return sum;
    }
}
public class CallableTest {
    public static void main(String[] args) {

        //3. 创建callable接口实现类的对象
        NumThread numThread = new NumThread();
        //4. 将此callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask<>(numThread);
        //5. 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Tread对象，并调用start( ) 方法。
        new Thread(futureTask).start();
        try {
            //get 方法的返回值为FutureTask构造器参数callable实现类重写的call()的返回值
            Object o = futureTask.get();
            System.out.println(Thread.currentThread().getName() + "  sum:"+ o);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
    }
}
```

Callable和Runnable对比：
1. call方法可以有返回值
2. call方法可以抛出异常，被外面的操作捕获，获取异常信息
3. Callable支持泛型

## 3.5 多线程创建方式4（JDK5）： 线程池

背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。
思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。

好处：
1. 提高响应速度（减少了创建新线程的时间）
2. 降低资源消耗（重复利用线程池中线程，不需要每次都创建）
3. 便于线程管理

corePoolSize：核心池的大小
maximumPoolSize：最大线程数
keepAliveTime：线程没有任务时最多保持多长时间后会终止

```java
class NumThread implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "----" + i);
        }
    }
}
public class ThreadPool {
    public static void main(String[] args) {
        //提供指定线程数量的线程池
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        //设置线程池的属性
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) executorService;
//        service1.setCorePoolSize(15);

        // 适合使用Runnable的操作
        executorService.submit(new NumThread());
        // 适合使用Callable
//        executorService.execute();
        //关闭连接池
        executorService.shutdown();
    }
}
```


# 4. Thread 常用方法

1. **start( )** : 启动当前线程，调用当前线程的run( )
2. **run( )** : 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中
3. **currentThread( )** : 静态方法，返回当前执行代码的线程
4. **getName( )** : 获取当前线程的名字
5. **setName( )** : 设置当前线程的名字
6.  **yield( )** : 释放当前cpu的执行权
7.  **join( )** : 在线程A中调用线程B的 join( ), 此时线程A就进入阻塞状态，直到线程B完全执行完之后，线程A才结束阻塞状态
8. **stop( )** : 已过时。强制结束当前线程。
9. **sleep(long millitime)** : 让当前线程睡眠指定的millitime 毫秒。在指定millitime毫秒时间内，当前线程是阻塞状态
10. isAlive( ) : 判断线程是否存活

# 5. 线程的优先级

MAX_PRIORITY: 10
MIN_PRIORITY: 1
NORN_PRIORITY: 5

获取和设置线程的优先级:
**getPriority( )**
**setPriority( )**

# 6. 线程的生命周期
![[线程的生命周期.png]]

1. 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态
2. 就绪：处于新建状态的线程被 **start( )** 后，将进入线程队列等待CPU时间片，此时它己具备了运行的条件，只是没分配到CPU资源
3. 运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，**run( )** 方法定义了线程的操作和功能
4. 阻塞：在其种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态
5. 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束


# 7. 线程同步

Q：多个线程执行的不确定性导致结果不稳定；多个线程操作的不完整性，破坏数据。


## 7.1 同步方式一：同步代码块
```java
synchronized(同步监视器){
	//需要被同步的代码
}
说明：操作共享数据的代码，即为需要被同步的代码
共享数据：多个线程共同操作的数据
```

```java
synchronized (this) {
    if (ticketCount > 0) {
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        System.out.println(Thread.currentThread().getName() + "售出票号" + ticketCount);
        ticketCount--;
    } else {
        break;
    }
}
```
说明：
1. 操作共享数据的代码，即为需要被同步的代码
2. 共享数据：多个线程共同操作的数据
3. 同步监视器，俗称：锁。任何一个类的对象，都可以称为锁
	要求：多个线索必须要同一把锁
4. 在实现Runnable接口创建多线程的方式中，可以使用this充当同步监视器

解决了线程的安全问题；但是操作代码时，只能有一个线程参与，其他线程等待，相当于单线程，效率低。

## 7.2 同步方式二：同步方法
如果操作共享数据的代码完整的声明在一个方法中，可以将此方法声明同步
1. 仍然使用同步监视器，但不需要显示声明
2. 非静态的同步方法，同步监视器为 this
	静态的同步方法，同步监视器为当前类
```java
private synchronized void show() {  // 同步监视器： .class 当前类

    if (ticketCount > 0) {
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        System.out.println(Thread.currentThread().getName() + "售出票号" + ticketCount);
        ticketCount--;
    }

}
```

## 7.3 同步方式三：Lock（锁）
ReentrantLock实现Lock
```java
private int count = 100;

    //实例化lock
    private ReentrantLock lock = new ReentrantLock(true);

    @Override
    public void run() {
        while (true) {
            try {
                //调用锁定方法lock()
                lock.lock();
                if (count > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    System.out.println(Thread.currentThread().getName() + "售出" + count);
                    count--;
                }else {
                    break;
                }
            } finally {
                //调用unlock()
                lock.unlock();
            }
        }
    }
}

public class LockTest {
    public static void main(String[] args) {
        Window window1 = new Window();
        Window window2 = new Window();
        Window window3 = new Window();
        new Thread(window1).start();
        new Thread(window2).start();
        new Thread(window3).start();
    }
```

## 7.4 synchronized 和 lock 的异同
同：二者都可以解决线程安全问题
不同：synchronized 机制在执行完相应的同步代码后自动释放同步监视器；
lock需要手动启动同步，结束也需手动解锁



# 8. 死锁
不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁，
1. 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。
2. 使用同步时，尽量避免死锁
```java
public static void main(String[] args) {

    StringBuffer sb1 = new StringBuffer();
    StringBuffer sb2 = new StringBuffer();
    new Thread(() -> {
        synchronized (sb1) {
            sb1.append("a");
            sb2.append("1");

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            synchronized (sb2) {
                sb1.append("b");
                sb2.append("2");
                System.out.println(sb1);
                System.out.println(sb2);
            }
        }

    }).start();

    new Thread(() -> {
        synchronized (sb2) {
            sb1.append("c");
            sb2.append("3");

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            synchronized (sb1) {
                sb1.append("d");
                sb2.append("4");
                System.out.println(sb1);
                System.out.println(sb2);
            }
        }
    }).start();
}
```

# 9. 线程通信
交替打印：
**wait( )** : 当前线程进入阻塞状态，并释放同步监视器。
**notify( )**  ：唤醒被wait的一个线程。如有多个，则唤醒优先高的。
**notifyAll( )** ：唤醒所有被wait的线程 。

1. 此上的方法必须在同步代码块或同步方法中调用
2. 调用者必须是同步代码块或同步方法的同步监视器

```java
synchronized (this) {
    //唤醒线程
    notify();
    if (num <= 100) {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "------"+ num);
        num++;
        try {
            //线程进入阻塞状态
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    } else {
        break;
    }
}
```
sleep( ) 与 wait( ) 的异同
同： 执行方法，都使线程进入阻塞状态
异： 1. 声明的位置不同：sleep( ) 是 Thread类声明的，wait( ) 是Object类中声明的
	    2. 调用的范围不同：sleep( ) 可以在任何需要的场景使用，wait( ) 必须在同步代码块或同步方法中
	    3. 在同步代码块或同步方法中，sleep( )不会释放锁，wait( ) 会释放锁